# Введение в контроль версий. Git.
***(Конспект)***



# Работа с ветками в Git

При использовании ветвления,  происходит отклонение от основной линии разработки. Работа продолжается независимо от неё, без вмешательства в основную линию. 

Ветвление позволяет создавать отдельные блоки внутри своего проекта, а также взаимодействовать между различными участниками проекта (в том числе удаленно), каждый из которых проводит свою часть работы в отдельной ветке. Затем ветки с помощью специальных комманд сливаются в один проект.

Новые ветки создают дополнительные указатели для перемещения между коммитами.

*Названия веток в Git - это указатели на коммиты.*

**Ветка являющаяся основной**, изначальной, имеет имя **master**.

*При этом из основной ветки master не видна информация, содержащаяся в отдельных ветвях, и наоборот, отдельные ветви отображают информацию,изначально содержащуюся в ветке master.*

**Текущая ветка и ее последний коммит**, в которой сейчас работаем имеет указатель **HEAD**. Указатель HEAD по существу указывает на тот коммит, после которого будет сделан следующий коммит. 

**HEAD всегда должен указывать на вершину какой-либо ветки.** Когда название ветки и положение HEAD совпадают, то имя ветки, допустим master, указывает на последний коммит в ветке master.

### !Состояние detached HEAD - отсоединенная голова!

Если загрузить какой-либо из предыдущих коммитов, то HEAD сместится туда.
При этом в рабочем каталоге состояние файлов возвращается к состоянию файлов этого коммита.
*Созданные коммиты ветки более поздних состояний, чем загружаемый коммит, никуда не исчезают.*

**Возникает состояние detached HEAD.**

Команда **git reflog** - просмотр истории перемещения головы.

Вызванный **git status показывает данное состояние красным цветом**, тк оно требует внимания.

**Внимание!** 
**Если в состоянии detached HEAD начать работать и создавать новые коммиты, есть большой риск их не то, чтобы совсем потерять, но ооочень долго искать с помощью различных команд и потерять при этом массу времени.**

Проблему возникают потому, что **в состоянии detached HEAD, _голова привязана к конкретному коммиту,_ а не к названию ветки.** Получается, что при создании новых коммитов фактически начинается ветвление, но без создания ветки. И **забыв идентификатор конкретного коммита**, первого в такой псевдоветке, **переключиться на него и все последующие коммиты, в последствии не получится**.

Если не можешь управлять - возглавь!
**"Лечение" подобных состояний - это самостоятельное создание новых веток** при работе из "старого" коммита. 

При перемещении по ветке в состоянии detached HEAD Git сам предложит создать новую ветку.

[Понятное, хотя и старенькое пособие по Git, в котором объясняются достаточно сложные моменты](https://webhamster.ru/mytetrashare/index/mtb0/1088)

## Просмотр коммитов при ветвлении

**По умолчанию команда git log - показывает коммиты текущей ветки!**

Для показа истории конкретной ветки необходимо использовать команду **git log Название ветки**

А чтобы посмотреть все существующие коммиты можно воспользоваться командой **git log --all**

**git log --graph** команда показывает цветную шкалу веток и их связей слева от их названий.


## Команды для работы с ветками

**git branch** показывает **существующие ветки**. При этом *текущая ветка*, в которой находимся сейчас *отмечена зеленым цветом и знаком \*.*

***

**git branch название** позволяет создать новую ветку.

**Помните!** *Данная команда создает ветку, но не переходит на нее автоматически.*

***

**git checkout название** команда переключения между ветками.

**git checkout master** - переход в основную ветку.

Можно использовать git branch, чтобы удостовериться в переходе.

***

**git merge название** команда для слияния веток. 

**Для ее осуществления необходимо сначала использовать git checkout master**, а уже **потом git merge название ветки**, которую будем сливать/соединять с основной.

После слияния веток, можно удалить побочную ветвь, используя **git checkout -d Название ветки**

**Важно!** _Комманда **git checkout -d** удаляет только уже слитые ветки, а команда **git checkout -D** удаляет ветки независимо от совершенных над ними действий. Таким образом можно полностью удалить и потерять не слитые ветки._

***

**При работе с ветками нельзя забывать о создании соответствующих коммитов.**

**ИНТЕРЕСНО:** что при команде git merge <ветка>, Git автоматически создаст "коммит слияния". То есть, Git не только изменит содержимое рабочего каталога, применяя вливаемые изменения, но и создаст "завершающий" коммит слияния. Таким образом, после слияния не нужно делать коммит, чтобы "зафиксировать" слияние. Однако следует помнить, что закоммичевание произойдет только в том случае, если при слиянии не было конфликтов.

## Конфликты при слиянии веток

**Слияние и конфликты являются неотъемлемой частью работы с Git.** В других инструментах управления версиями, например SVN, работа с конфликтами может быть дорогой и времязатратной.

 Git позволяет выполнять слияния очень просто. В большинстве случаев Git самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Если при сливании веток информация конфликтует, то в общем окне отображаются оба варианта
Heads и "название ветки".

Конфликт выглядит следующим образом:

Accept Current Change|Accept Incoming Change|Accept Both Chenge

* \<<<<<<<HEAD
* \=======
* \>>>>>>> название ветки

Где \====== - центр конфликта.  
Все содержимое между этим центром и строкой \<<<<<<< HEAD находится в текущей ветке, на которую ссылается указатель HEAD. 

Все содержимое между центром и строкой \>>>>>>> *название ветки* является содержимым ветки для слияния.

Можно выбрать самостоятельно подходящий итоговый вариант. Для этого в верху этого блока есть меню, либо можно отредактировать вручную и устранить конфликт, а потом закоммитить изменения.










# Журнал изменений
Для просмотра истории изменений используется комманда *git log*

Для создания коммитов - фиксаций состояний используется комманда *git commit* -m "комментарий писать обязательно"

Для создания репозиторияв папке необходимо использовать команду *git init* Жту команду пишем в терминале соткрытой папкой - репозиторием.

## Создание сохранений

Для добавления файлов к commit используется комманда *git add*. Чтобы добавить файл к новому коммиту нужно написать в терминале данную комманду.

## Перемещение между коммитами
Для перемещения между коммитами используется команда git checkout номер коммита. Номера коммитов можно посмотреть коммандой...


# Журнал изменений
Для просмотра истории изменений используется комманда *git log*

